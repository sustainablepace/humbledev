Title:

Tactical Design by Example - Using Kotlin and Spring Boot (Part 9) - Behaviour, not data

----

Description:

Tactical Design by Example - Using Kotlin and Spring Boot (Part 9) - Behaviour, not data

----

Date:

09/11/2020

----

Tags:

ddd, kotlin, hexagon architecture, spring boot

----

Text:

Let's take a look at the __evolution of an application__: Today, most development is done in __iterations__, so applications __start out with a minimal feature set__, and are __growing steadily over time__. It is not uncommon to end up with very complicated code after only a few iterations, that is __hard to extend and maintain__. Often, a __rewrite or abandonment__ are the only options left.

This is not a problem per se. But I'm arguing here that a __data-centric__ perspective might be a cause of this phenomenon, and a __behaviour-centric__ perspective might help __reducing complexity__ and allow __lengthening the life-cycle__ of an application. So it might be a good idea if you want to create something of value, something to rely on in the long run.

Let's sketch a very broad picture in this blog post of what I mean by a data-centric perspective.

## Data-centric perspective

Most applications start out small: Usually, there is a client-side and a server-side component, where the job of the server-side component is to do __persistence__ or publication, and expose itself to the client-side through a __web interface__. Let's focus on the server side for now.

For persistence, a __relational database__ is still a popular choice. For a web interface, a __REST API__ is the default option. As far as programming languages are concerned, __object-oriented languages__ like Java are still an industry default. I'm arguing that this tool set will most likely lead to the application being modelled as a CRUD application.

### CRUD applications

In a CRUD application, there are only __four kinds of behaviours__: create, read, update, delete. These are also the basic __HTTP verbs__, and also the basic __relational database operations__ (insert, select, update, delete). Object-oriented languages are traditionally (mis?-)using objects as data containers, exposing the data via __getters and setters__.

So the choice of the tools will have an immediate effect on the solution of the problem: __When you have a hammer, everything looks like a nail.__

The limitations of CRUD are of course also charming: The concept is __widely understood__ and usually __progress is made really fast__. If the scope of the application in question is strictly limited, it might be a good choice. But usually, the __limitations are exceeded__ rather sooner than later, and to make it worse, __developers are hardly ever aware__ of that.

## Symptoms of a data-centric perspective

### The problem with JPA

In a Spring application that is designed for CRUD, JPA is a popular choice for accessing the database. It is an overwhelmingly powerful tool that is deceptively easy to use. It works really well for the standard use-cases, but it forces your application to obtain a database-centric view, because the JPA entities themselves are modelled after the table layout.

JPA entities are often anemic domain models, as they represent the data as it is stored in the database. They are mutable, because changes are only flushed to the database when the object is actually changed. Because immutability is discouraged, side-effects are not uncommon and more complexity is added.

### Almighty services

Usually in this setup, the application services are clustered by entity. So if you have an "order" entity, you usually have an "order" service. This works quite well if you only have one entity: but as soon as two entities are depending on one another, it soon becomes arbitrary in which class an application service method is put, and you might end up with circular dependencies.

These service classes usually grow to an unmaintainable size. There is no definition of what their job is. Often, they absorb all application logic like a black hole. This makes testing hard: If a class is huge, it also has a huge test class, where you easily get lost when trying to find the right test case. This leads to missing test cases, and also overlapping tests. Also, mocking becomes a nightmare, because a service all of a sudden has loads of dependencies.

Refactorings often only scratch the surface, because the keep the underlying system in place, and only move a bit of code from left to right. Improvement within this frame of mind is hardly possible.

## Behaviour-centric perspective

Apparently adding new features is hard when code has to be altered. __Adding and removing code is easy, but changes are hard__. If your code has a data-centric view, consequences of changes are often global, because the data is used everywhere.

We would like to have a code base where new features translate to new code, not altered code. This is what I mean by behaviour-centric: any new feature is a new behaviour, which can be added as new code rather than change existing code. We need to structure our application in a way that allows this style of development. I will elaborate on behaviour-centric development in the next weeks, so stay tuned!

Go back to (link:blog/tactical-design-by-example-using-kotlin-and-spring-boot-part-8-sliced-tests text:part eight).




